## 1\. Общее описание проекта

Этот репозиторий содержит решение для курсового задания по разработке **конвертера**, который переводит конфигурационный файл, написанный на нашем **учебном DSL (Domain Specific Language)**, в общепринятый формат **YAML**.

Основная работа конвертера лежит в двух этапах:

1.  **Парсинг:** С помощью библиотеки **Lark** и **LALR-алгоритма** мы строим **Абстрактное Синтаксическое Дерево (AST)**.
2.  **Трансляция:** Специализированный **Трансформер** выполняет обход этого дерева. На этом этапе происходит самое главное — **вычисление всех константных выражений**, написанных в **обратной польской записи (Postfix Notation)**.

В конечном итоге, преобразованная структура данных сериализуется в формат YAML с использованием **PyYAML**.

### Синтаксис нашего DSL

Наш язык поддерживает следующие базовые конструкции:

  * **Константы:** объявляются глобально, например: `global NAME = значение;`.
  * **Данные:** организованы в **словари** (`[ключ => значение]`) и **массивы** (`(list значение1 значение2)`).
  * **Вычисления:** любое выражение, заключенное в `^{...}`, вычисляется на этапе трансляции, например: `^{ операнд1 операнд2 операция }`.


## 2\. Архитектура и описание компонентов

Вся логика сосредоточена в файле **`main.py`**. Проект организован вокруг трех ключевых компонентов.

### 2.1. Грамматика (`GRAMMAR`)

Здесь определены все правила языка. Грамматика описывает, как выглядят наши структуры:

  * **Декларация констант (`const_decl`)** и их использование как простых имён (`NAME`).
  * Структурные элементы: **словари (`dict`)** и **массивы (`array`)**.
  * Самое сложное — **константные выражения (`const_expr`)**. Внутри них могут встречаться базовые литералы (`NUMBER`, `STRING`, `BOOL`), имена констант и **операции (`OPERATION`)**.

Поддерживаются как однострочные (`//`), так и многострочные (`#| ... |#`) комментарии.

### 2.2. Класс `ConfigTransformer`

Этот класс, наследующий функционал Lark, отвечает за перевод узлов AST в реальные Python-объекты.

  * **Управление константами:** Метод `const_decl` наполняет внутренний словарь `self.constants`, доступный для всего парсинга.
  * **Вычислительное ядро:** Методы `_eval_postfix` и `_apply_operation` реализуют логику **стекового калькулятора**. Они обрабатывают операнды и последовательно применяют операции.
      * **Поддерживаемые функции:** базовые арифметические операции (`+`, `-`, `*`, `/`), а также `sqrt` и `len`.
      * **Важный момент:** метод `value` умеет распознавать, когда в словаре используется просто имя константы (`NAME`), и заменяет его на актуальное значение из `self.constants`.

### 2.3. Класс `ConfigConverter`

Это точка входа, которая объединяет парсер и трансформер. Класс отвечает за чтение входного файла (`parse_file`), пре-обработку контента (удаление многострочных комментариев в `parse_content`) и, наконец, вызов `yaml.dump` для генерации финального YAML-выхода (`convert_to_yaml`).


## 3\. Разработка и запуск

### 3.1. Установка и зависимости

Для работы проекта необходимы библиотеки Lark и PyYAML. Все зависимости указаны в файле **`requirements.txt`**.

# Устанавливаем все, что нужно, одной командой
pip install -r requirements.txt

### 3.2. Запуск конвертера

Запуск происходит через командную строку. Необходимо указать путь к входному файлу (`.conf`).

# Общий шаблон запуска
python main.py -i <путь/к/файлу.conf>

# Пример
python main.py -i config_web.conf

## 4\. Примеры конфигураций

В репозитории представлены три примера, демонстрирующие весь функционал языка:

1.  **`config_web.conf`**: Настройки сервера.
2.  **`config_game.conf`**: Игровая логика.
3.  **`config_db.conf`**: Конфигурация базы данных.